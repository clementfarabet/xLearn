toolBox Package Reference Manual

toolBox is... well, a collection of useful tools and functions (provided with =xLearn=).

---+ =toolBox.unpack(args, funcname, description, ...)=
#toolBox_unpack

=toolBox.unpack= is a convenient method to create consistent function calls
that can be named or ordered. It also handles defaults, and check for required
arguments. Finally, it automatically generates complete online help messages 
when an error is found (missing argument,...).

=toolBox.unpack= is typically called on the varargs of a user function, {...}.

For example:
<verbatim>
-- define a function:
function image.smooth(...)
   local args, img, sigma, name = toolBox.unpack(
       {...},
       'image.smooth', 
       'this function demonstrates how to use unpack',
       {arg='image', type='torch.Tensor', help='input image (WxHx3)', req=true},
       {arg='sigma', type='number', help='smoothing sigma', default=0.7},
       {arg='name', type='string', help='name for image'}
   )
   if img:nDimension() ~= 3 then
      -- the error message (online help) is available like this too:
      error(args.usage)
   end
   local res = image.convolve(img,image.gaussian(sigma))
   return res,name
end

-- calling function without argument will dump its help string:
> image.smooth()
ERROR: 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
NAME:
image.smooth

DESC:
this function demonstrates how to use unpack

EXAMPLE:
image.smooth{sigma=number, image=torch.Tensor}
image.smooth(torch.Tensor, ...)

USAGE:
image.smooth{
    image = torch.Tensor                -- input image
    [sigma = number]                    -- smoothing sigma  [default = 0.7]
    [name = string]                     -- name for image
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

-- the previous message indicates clearly how to use the function, thanks
-- to unpack !!
-- now try again, with actual arguments:
> lena = image.lena()
> res = image.smooth(lena,0.4)

-- the previous call was using ordered arguments, unpack can automatically 
-- detect and handle named arguments too:
> res = image.smooth{image=lena, name='testname'}

-- note the use of a table to pass the named arguments.

</verbatim>


---+ =toolBox.unpack_class(object, args, funcname, description, ...)=
#toolBox_unpack_class

=toolBox.unpack_class= is a convenient method to create consistent function calls
that can be named or ordered. It also handles defaults, and check for required
arguments. Finally, it automatically generates complete online help messages 
when an error is found (missing argument,...).

=toolBox.unpack_class= is typically called on the varargs of a _constructor_ function.

It works exactly as [[#toolBox_unpack][=toolBox.unpack=]], except that the first 
argument is the _self_, or whatever table we want the arguments to be unpacked in.


---+ =toolBox.sleep(seconds)=
#toolBox_sleep

A simple sleep function. Time is a floating point number, in seconds.


---+ =toolBox.dispProgress(current, goal)=
#toolBox_dispProgress

Displays a progress bar.


---+ =toolBox.isJIT()=
#toolBox_isJIT

Returns true if LuaJIT is the interpreter in use.


---+ =toolBox.error(message, domain, usage)=
#toolBox_error

Displays a formatted error message.

=usage= is usually the usage string generated by [[#toolBox_unpack][=toolBox.unpack=]].


---+ =toolBox.exec(cmd)=
#toolBox_exec

Executes the shell command provided. Works exactly as =os.execute(cmd)= but also
returns the result as a string.


---+ =toolBox.getOS()=
#toolBox_getOS

Returns a string containing the OS name. This is called when loading the lib, and 
set into =toolBox.OS=.


---+ =toolBox.require()=
#toolBox_require

Checks the existence of a module, and then loads it. Prints a warning if the module
could not be found (the default =require()= from Lua crashes instead...).


---+ =toolBox.ls(options)=
#toolBox_ls

An alias for =toolBox.exec('ls ' .. options)=. Returns the result in a string.

Can also be used to create smart symbols:
<verbatim>
> ls_l = toolBox.ls('-l')
> ls_l
-- prints the content of the current directory
</verbatim>

By default, 4 symbols are created in the global namespace: =ls=, =ll=, =la= and =lla=.


---+ =toolBox.readbinaryfile(filename, object)=
#toolBox_readbinaryfile

Read a binray file on the disk and put the content into object.
Object must be of the same type as the object contained in the file.
This routine just put together a torchDiskfile and the read method of the given object.

here is the equivalent with toch methods
<verbatim>
> f = torch.DiskFile(filename):binary()
> object:read(f)
> f:close()
> return object
</verbatim>

---+ =toolBox.writebinaryfile(filename, object)=
#toolBox_writebinaryfile

Write a binray file on the disk.
This routine just put together a torchDiskfile and the write method of the given object.

here is the equivalent with toch methods
<verbatim>
> f = torch.DiskFile(filename,'w'):binary()
> object:write(f)
> f:close()
> return object
</verbatim>